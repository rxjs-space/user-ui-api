# Angular 2的大小与性能

今天有人提出一个问题：Angular的AoT编译能做到60k了，能不能做到20k？不过我的答复是：有什么用？要知道，现在就算是手机网站上的一张图，也动辄100k开外呢，我们从js中减去40k有什么意义呢？

在现在的4G网速下，就算是减去100k，对于用户体验也不会产生多少可见的提升。而如果用户还在用2G网络，你要先想一下，他是你的目标用户吗？事实上很多应用的设计目标都不包括2G用户。

所以，我们要先弄清楚自己的根本目标是什么，否则必然事倍功半。

开发任何应用系统的目标都是为目标用户群提供最佳的服务，超出目标用户群的需求则属于nice to have（有更好，没有也无所谓）。有了清晰的目标，研发投入才不会浪费。

事实上，在软件项目中，有很多指标都比“性能”重要很多，特别是可维护性。而损伤可维护性最大的实践，恰恰是追求“性能”。况且，“性能”本身并不是产品的指标。作为最终的产品，我们关心的实际上是它的最终表现，比如首屏加载速度是性能的外在表现、用户操作流畅度是性能的外在表现、动画流畅度也是性能的外在表现。

所以，我们应该从外在表现来判定性能是否合格，而不应该无限制的追求数字。

## 优化三定律

这让我想起了很多年前一本讲C++的书（抱歉，忘了名字）上所提的“（性能）优化三定律”：

### 不要优化。

很多优化都有代价，甚至适得其反。因为对于常规写法，好的编译器会在内部帮你优化；而你自创的“优化”代码，编译器无法识别，于是你优化过的代码**事实上更慢**。
    
### **（只适用于专家）**不要优化。

盲目的优化会浪费你的时间，耽误更重要的事，并且劣化你的代码结构，损失可读性。让“清晰”的代码变快很容易，但是想让“快而混乱”的代码变清晰可就不那么容易了。

### 在**测量**的基础上优化。

代码中同样存在80/20定律 —— 80%的时间花在了20%的代码上，其实在很多场景下这个比例还要更悬殊一些。因此，优化是一项系统工程，需要整体考虑，而不是只考虑其中的一小部分。

## Angular 2的性能

在前端程序中，我们有三个非常重要的指标：

### 首屏加载速度

这个问题在手机版会特别明显。在Angular 1和Angular 2的早期版本中，都只能先把HTML模板加载到内存里，然后等应用的js代码全都下载完了，才能进行编译，再把编译结果放到DOM中。这个过程中很多时间都在等待，这可能要花一秒钟以上，确实很慢。

后来，Angular 2推出了一项叫做Universal的配套技术，它的用途是服务端渲染。它需要在部署Angular程序的服务器上部署一个NodeJS小程序（通用性很强）。当浏览器请求一个URL时，Angular就先在内存中把模板编译成DOM，并从中提取出HTML，然后把这段HTML发回给浏览器。这样一来，浏览器就可以直接渲染出这段HTML，而不用等js下载完了。在实测时，它的表现和静态HTML文件几乎毫无区别。

再后来，Angular 2推出了一项叫做预(AoT)编译的技术，这项技术可以从两个方面提高首屏加载速度。首先，它把HTML在开发打包时就预编译成用来创建DOM节点的js文件。当浏览器拿到js文件时，这段js代码就会直接开始创建DOM节点，而不用等收到DOMContentLoaded事件之后才开始工作，因此有效的消灭了白屏。其次，它在编译期就完成了模板编译，因此Angular中用来实现模板编译的那部分代码就不用发布到浏览器中，而这部分代码又几乎占了Angular大小的一半儿，因此有效的节省了大小。最后，由于完全编译成了js文件，因此借助Tree-Shaking技术，核心库中那些没有用过的指令就能够被识别为死代码，并从最终的发布包中移除。

### 用户操作流畅度

在Angular 1中，变更检测的算法效率是很低的，这主要是因为它会通过一个三重循环来实现变更检测。不过其实在大多数场景下你都察觉不到这一点。

而Angular 2中重新设计了这个算法，平均而言其性能提升了500%。因此，即使是在手机上，你也已经感受不到速度的损失了。

### 动画性能

严格来讲，动画其实并不是前端程序所能解决的问题。大多数的动画都是CSS动画，JS只是为它提供参数。当然，在少数单线程或内存较低的手机上，程序自身占用的CPU和内存会在一定程度上影响动画的性能，不过随着手机性能按照摩尔定律进行提升，并且手机浏览器内核也做了显著优化（据说Android 7的浏览器上某些性能提升了600%），前端程序对动画性能的影响已经越来越小了，可以不必忧虑。

## 客观评测数据

关于Angular 2的性能有两个客观评测（针对的是Final之前的版本）可以参阅（微信中请点击“阅读原文”链接）：

[dbmon](http://mathieuancelin.github.io/js-repaint-perfs/)

[Table Report](https://cdn.rawgit.com/krausest/js-framework-benchmark/a358bc967e1d9ff0c268b43f5ab8b832abe0476e/webdriver-java/table.html)

可以看到，它在这里的大部分单项测试中都处于领先或平均的状态。唯一显著落后的一项是在10000行的表格中插入1000行（大部分人一辈子也遇不到这种需求）。而且，这还是在Angular尚未集成WebWorker的前提下。从原理可知，一旦集成了WebWorker，它的性能应该会有显著提升。

## Angular 2的大小

正如前面所说，Angular 2的最小传输流量（gzip之后的流量）已经降低到了60k，而且借助Cache-Busting技术，它可以在前端设备上无限期缓存，因此在大多数应用中，对大小的顾虑已经完全可以抛开了。

## 结论

即使在Angular 2中大小和性能已经不是问题，但我仍然要再强调一遍：用大小甚至性能来换取更快的开发速度和更好的工程化支持，在现代软件开发中几乎总是划算的。记住：“让清晰的程序变快很简单，让快（却混乱）的程序变清晰可就没那么容易了”！
